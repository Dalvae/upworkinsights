import { Hono } from 'hono';
import type { SupabaseClient } from '@supabase/supabase-js';
import { normalizeJob, extractSkills } from '../lib/normalize';
import type { IngestPayload, RawUpworkJob } from '../types';
import { requireApiKey } from '../middleware/auth';

type Env = { Variables: { db: SupabaseClient; serviceDb: SupabaseClient } };

const app = new Hono<Env>();

function isValidRawJob(raw: unknown): raw is RawUpworkJob {
  if (!raw || typeof raw !== 'object') return false;
  const r = raw as Record<string, unknown>;
  return (
    typeof r.ciphertext === 'string' && r.ciphertext.length > 0 &&
    typeof r.title === 'string' &&
    typeof r.description === 'string'
  );
}

async function upsertJobAndSkills(db: SupabaseClient, raw: RawUpworkJob, sourceUrl?: string | null) {
  const job = normalizeJob(raw, sourceUrl, null);
  const skills = extractSkills(raw);

  // Check if job already exists to detect changes
  const { data: existing } = await db
    .from('jobs')
    .select('id, proposals_tier, freelancers_to_hire, is_applied, total_hired, total_applicants')
    .eq('ciphertext', job.ciphertext)
    .single();

  const shouldSnapshot = !existing ||
    existing.proposals_tier !== job.proposals_tier ||
    existing.freelancers_to_hire !== job.freelancers_to_hire ||
    existing.is_applied !== job.is_applied ||
    (job.total_hired > 0 && existing.total_hired !== job.total_hired) ||
    (job.total_applicants && existing.total_applicants !== job.total_applicants);

  let jobId: number;

  if (existing) {
    // Update existing job
    const { error: updateError } = await db.from('jobs').update({
      title: job.title,
      description: job.description,
      last_seen_at: new Date().toISOString(),
      job_type: job.job_type,
      duration: job.duration,
      engagement: job.engagement,
      fixed_budget: job.fixed_budget,
      hourly_min: job.hourly_min,
      hourly_max: job.hourly_max,
      tier: job.tier,
      proposals_tier: job.proposals_tier,
      is_premium: job.is_premium,
      freelancers_to_hire: job.freelancers_to_hire,
      is_applied: job.is_applied,
      client_country: job.client_country,
      client_payment_verified: job.client_payment_verified,
      client_total_spent: job.client_total_spent,
      client_total_reviews: job.client_total_reviews,
      client_total_feedback: job.client_total_feedback,
      client_quality_score: job.client_quality_score,
      source_url: job.source_url,
      search_query: job.search_query,
      ...(job.job_status && { job_status: job.job_status }),
      ...(job.total_hired > 0 && { total_hired: job.total_hired }),
      ...(job.total_applicants && { total_applicants: job.total_applicants }),
      ...(job.total_invited_to_interview > 0 && { total_invited_to_interview: job.total_invited_to_interview }),
      ...(job.invitations_sent > 0 && { invitations_sent: job.invitations_sent }),
      ...(job.unanswered_invites > 0 && { unanswered_invites: job.unanswered_invites }),
      ...(job.last_buyer_activity && { last_buyer_activity: job.last_buyer_activity }),
      ...(job.client_total_assignments != null && { client_total_assignments: job.client_total_assignments }),
      ...(job.client_active_assignments != null && { client_active_assignments: job.client_active_assignments }),
      ...(job.client_total_jobs_with_hires != null && { client_total_jobs_with_hires: job.client_total_jobs_with_hires }),
      ...(job.client_open_jobs != null && { client_open_jobs: job.client_open_jobs }),
      ...(job.qualifications != null && { qualifications: job.qualifications }),
      ...(job.segmentation_data != null && { segmentation_data: job.segmentation_data }),
      ...(job.tools != null && { tools: job.tools }),
      ...(job.qualification_matches != null && { qualification_matches: job.qualification_matches }),
    }).eq('id', existing.id);
    if (updateError) throw updateError;
    jobId = existing.id;
  } else {
    // Insert new job (id is auto-generated by BIGSERIAL)
    const { data: inserted, error: insertError } = await db.from('jobs').insert({
      ciphertext: job.ciphertext,
      title: job.title,
      description: job.description,
      created_on: job.created_on,
      published_on: job.published_on,
      last_seen_at: new Date().toISOString(),
      job_type: job.job_type,
      duration: job.duration,
      engagement: job.engagement,
      fixed_budget: job.fixed_budget,
      hourly_min: job.hourly_min,
      hourly_max: job.hourly_max,
      tier: job.tier,
      proposals_tier: job.proposals_tier,
      is_premium: job.is_premium,
      freelancers_to_hire: job.freelancers_to_hire,
      is_applied: job.is_applied,
      client_country: job.client_country,
      client_payment_verified: job.client_payment_verified,
      client_total_spent: job.client_total_spent,
      client_total_reviews: job.client_total_reviews,
      client_total_feedback: job.client_total_feedback,
      client_quality_score: job.client_quality_score,
      source_url: job.source_url,
      search_query: job.search_query,
      job_status: job.job_status,
      total_hired: job.total_hired,
      total_applicants: job.total_applicants,
      total_invited_to_interview: job.total_invited_to_interview,
      invitations_sent: job.invitations_sent,
      unanswered_invites: job.unanswered_invites,
      last_buyer_activity: job.last_buyer_activity,
      client_total_assignments: job.client_total_assignments,
      client_active_assignments: job.client_active_assignments,
      client_total_jobs_with_hires: job.client_total_jobs_with_hires,
      client_open_jobs: job.client_open_jobs,
      qualifications: job.qualifications,
      segmentation_data: job.segmentation_data,
      tools: job.tools,
      qualification_matches: job.qualification_matches,
    }).select('id').single();
    if (insertError) throw insertError;
    jobId = inserted!.id;
  }

  // Save snapshot if this is new or something changed
  if (shouldSnapshot) {
    await db.from('job_snapshots').insert({
      job_id: jobId,
      proposals_tier: job.proposals_tier,
      freelancers_to_hire: job.freelancers_to_hire,
      is_applied: job.is_applied,
      total_hired: job.total_hired || null,
      total_applicants: job.total_applicants || null,
    });
  }

  if (skills.length > 0) {
    await db.from('skills').upsert(
      skills.map((s) => ({ uid: s.uid, label: s.label })),
      { onConflict: 'uid' }
    );
    await db.from('job_skills').upsert(
      skills.map((s) => ({ job_id: jobId, skill_uid: s.uid, is_highlighted: s.is_highlighted })),
      { onConflict: 'job_id,skill_uid' }
    );
  }

  return { isNew: !existing };
}

app.post('/ingest', requireApiKey(), async (c) => {
  const db = c.get('serviceDb');
  const payload: IngestPayload = await c.req.json();

  if (!payload.jobs || !Array.isArray(payload.jobs)) {
    return c.json({ error: 'Invalid payload: jobs array required' }, 400);
  }

  let inserted = 0;
  let updated = 0;
  let errors = 0;

  for (const raw of payload.jobs) {
    if (!isValidRawJob(raw)) {
      errors++;
      continue;
    }
    try {
      const result = await upsertJobAndSkills(db, raw, payload.url);
      if (result.isNew) inserted++;
      else updated++;
    } catch (e) {
      console.error('Ingest error:', e);
      errors++;
    }
  }

  return c.json({ ok: true, received: payload.jobs.length, inserted, updated, errors });
});

app.post('/import/bulk', requireApiKey(), async (c) => {
  const db = c.get('serviceDb');
  const body = await c.req.json();

  let allJobs: RawUpworkJob[] = [];
  let sourceUrl: string | null = null;

  if (Array.isArray(body)) {
    for (const payload of body) {
      if (payload.jobs) allJobs.push(...payload.jobs);
    }
  } else if (body.jobs) {
    allJobs = body.jobs;
    sourceUrl = body.url || null;
  }

  if (allJobs.length === 0) {
    return c.json({ error: 'No jobs found in payload' }, 400);
  }

  let inserted = 0;
  let errors = 0;

  for (const raw of allJobs) {
    if (!isValidRawJob(raw)) {
      errors++;
      continue;
    }
    try {
      await upsertJobAndSkills(db, raw, sourceUrl);
      inserted++;
    } catch (e) {
      console.error('Bulk import error:', e);
      errors++;
    }
  }

  return c.json({ ok: true, total: allJobs.length, inserted, errors });
});

export default app;
